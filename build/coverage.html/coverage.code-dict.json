{"/home/travis/build/npmtest/node-npmtest-dat/test.js":"/* istanbul instrument in package npmtest_dat */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - pre-init\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        switch (local.modeJs) {\n        // re-init local from window.local\n        case 'browser':\n            local = local.global.utility2.objectSetDefault(\n                local.global.utility2_rollup || local.global.local,\n                local.global.utility2\n            );\n            break;\n        // re-init local from example.js\n        case 'node':\n            local = (local.global.utility2_rollup || require('utility2'))\n                .requireExampleJsFromReadme();\n            break;\n        }\n        // export local\n        local.global.local = local;\n    }());\n\n\n\n    // run shared js-env code - function\n    (function () {\n        return;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // run browser js-env code - function\n    case 'browser':\n        break;\n\n\n\n    // run node js-env code - function\n    case 'node':\n        break;\n    }\n\n\n\n    // run shared js-env code - post-init\n    (function () {\n        return;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // run browser js-env code - post-init\n    case 'browser':\n        local.testCase_browser_nullCase = local.testCase_browser_nullCase || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test browsers's null-case handling-behavior-behavior\n         */\n            onError(null, options);\n        };\n\n        // run tests\n        local.nop(local.modeTest &&\n            document.querySelector('#testRunButton1') &&\n            document.querySelector('#testRunButton1').click());\n        break;\n\n\n\n    // run node js-env code - post-init\n    /* istanbul ignore next */\n    case 'node':\n        local.testCase_buildApidoc_default = local.testCase_buildApidoc_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildApidoc's default handling-behavior-behavior\n         */\n            options = { modulePathList: module.paths };\n            local.buildApidoc(options, onError);\n        };\n\n        local.testCase_buildApp_default = local.testCase_buildApp_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildApp's default handling-behavior-behavior\n         */\n            local.testCase_buildReadme_default(options, local.onErrorThrow);\n            local.testCase_buildLib_default(options, local.onErrorThrow);\n            local.testCase_buildTest_default(options, local.onErrorThrow);\n            local.testCase_buildCustomOrg_default(options, local.onErrorThrow);\n            options = [];\n            local.buildApp(options, onError);\n        };\n\n        local.testCase_buildCustomOrg_default = local.testCase_buildCustomOrg_default ||\n            function (options, onError) {\n            /*\n             * this function will test buildCustomOrg's default handling-behavior\n             */\n                options = {};\n                local.buildCustomOrg(options, onError);\n            };\n\n        local.testCase_buildLib_default = local.testCase_buildLib_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildLib's default handling-behavior\n         */\n            options = {};\n            local.buildLib(options, onError);\n        };\n\n        local.testCase_buildReadme_default = local.testCase_buildReadme_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildReadme's default handling-behavior-behavior\n         */\n            options = {};\n            local.buildReadme(options, onError);\n        };\n\n        local.testCase_buildTest_default = local.testCase_buildTest_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildTest's default handling-behavior\n         */\n            options = {};\n            local.buildTest(options, onError);\n        };\n\n        local.testCase_webpage_default = local.testCase_webpage_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test webpage's default handling-behavior\n         */\n            options = { modeCoverageMerge: true, url: local.serverLocalHost + '?modeTest=1' };\n            local.browserTest(options, onError);\n        };\n\n        // run test-server\n        local.testRunServer(local);\n        break;\n    }\n}());\n","/home/travis/build/npmtest/node-npmtest-dat/lib.npmtest_dat.js":"/* istanbul instrument in package npmtest_dat */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - pre-init\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        // init utility2_rollup\n        local = local.global.utility2_rollup || local;\n        // init lib\n        local.local = local.npmtest_dat = local;\n        // init exports\n        if (local.modeJs === 'browser') {\n            local.global.utility2_npmtest_dat = local;\n        } else {\n            module.exports = local;\n            module.exports.__dirname = __dirname;\n            module.exports.module = module;\n        }\n    }());\n}());\n","/home/travis/build/npmtest/node-npmtest-dat/example.js":"/*\nexample.js\n\nquickstart example\n\ninstruction\n    1. save this script as example.js\n    2. run the shell command:\n        $ npm install npmtest-dat && PORT=8081 node example.js\n    3. play with the browser-demo on http://127.0.0.1:8081\n*/\n\n\n\n/* istanbul instrument in package npmtest_dat */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - pre-init\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        // init utility2_rollup\n        local = local.global.utility2_rollup || (local.modeJs === 'browser'\n            ? local.global.utility2_npmtest_dat\n            : global.utility2_moduleExports);\n        // export local\n        local.global.local = local;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // post-init\n    // run browser js-env code - post-init\n    /* istanbul ignore next */\n    case 'browser':\n        local.testRunBrowser = function (event) {\n            if (!event || (event &&\n                    event.currentTarget &&\n                    event.currentTarget.className &&\n                    event.currentTarget.className.includes &&\n                    event.currentTarget.className.includes('onreset'))) {\n                // reset output\n                Array.from(\n                    document.querySelectorAll('body > .resettable')\n                ).forEach(function (element) {\n                    switch (element.tagName) {\n                    case 'INPUT':\n                    case 'TEXTAREA':\n                        element.value = '';\n                        break;\n                    default:\n                        element.textContent = '';\n                    }\n                });\n            }\n            switch (event && event.currentTarget && event.currentTarget.id) {\n            case 'testRunButton1':\n                // show tests\n                if (document.querySelector('#testReportDiv1').style.display === 'none') {\n                    document.querySelector('#testReportDiv1').style.display = 'block';\n                    document.querySelector('#testRunButton1').textContent =\n                        'hide internal test';\n                    local.modeTest = true;\n                    local.testRunDefault(local);\n                // hide tests\n                } else {\n                    document.querySelector('#testReportDiv1').style.display = 'none';\n                    document.querySelector('#testRunButton1').textContent = 'run internal test';\n                }\n                break;\n            // custom-case\n            default:\n                break;\n            }\n            if (document.querySelector('#inputTextareaEval1') && (!event || (event &&\n                    event.currentTarget &&\n                    event.currentTarget.className &&\n                    event.currentTarget.className.includes &&\n                    event.currentTarget.className.includes('oneval')))) {\n                // try to eval input-code\n                try {\n                    /*jslint evil: true*/\n                    eval(document.querySelector('#inputTextareaEval1').value);\n                } catch (errorCaught) {\n                    console.error(errorCaught);\n                }\n            }\n        };\n        // log stderr and stdout to #outputTextareaStdout1\n        ['error', 'log'].forEach(function (key) {\n            console[key + '_original'] = console[key];\n            console[key] = function () {\n                var element;\n                console[key + '_original'].apply(console, arguments);\n                element = document.querySelector('#outputTextareaStdout1');\n                if (!element) {\n                    return;\n                }\n                // append text to #outputTextareaStdout1\n                element.value += Array.from(arguments).map(function (arg) {\n                    return typeof arg === 'string'\n                        ? arg\n                        : JSON.stringify(arg, null, 4);\n                }).join(' ') + '\\n';\n                // scroll textarea to bottom\n                element.scrollTop = element.scrollHeight;\n            };\n        });\n        // init event-handling\n        ['change', 'click', 'keyup'].forEach(function (event) {\n            Array.from(document.querySelectorAll('.on' + event)).forEach(function (element) {\n                element.addEventListener(event, local.testRunBrowser);\n            });\n        });\n        // run tests\n        local.testRunBrowser();\n        break;\n\n\n\n    // run node js-env code - post-init\n    /* istanbul ignore next */\n    case 'node':\n        // export local\n        module.exports = local;\n        // require modules\n        local.fs = require('fs');\n        local.http = require('http');\n        local.url = require('url');\n        // init assets\n        local.assetsDict = local.assetsDict || {};\n        /* jslint-ignore-begin */\n        local.assetsDict['/assets.index.template.html'] = '\\\n<!doctype html>\\n\\\n<html lang=\"en\">\\n\\\n<head>\\n\\\n<meta charset=\"UTF-8\">\\n\\\n<meta name=\"viewport\" content=\"width=device-width, initial-scale=1\">\\n\\\n<title>{{env.npm_package_name}} (v{{env.npm_package_version}})</title>\\n\\\n<style>\\n\\\n/*csslint\\n\\\n    box-sizing: false,\\n\\\n    universal-selector: false\\n\\\n*/\\n\\\n* {\\n\\\n    box-sizing: border-box;\\n\\\n}\\n\\\nbody {\\n\\\n    background: #dde;\\n\\\n    font-family: Arial, Helvetica, sans-serif;\\n\\\n    margin: 2rem;\\n\\\n}\\n\\\nbody > * {\\n\\\n    margin-bottom: 1rem;\\n\\\n}\\n\\\n.utility2FooterDiv {\\n\\\n    margin-top: 20px;\\n\\\n    text-align: center;\\n\\\n}\\n\\\n</style>\\n\\\n<style>\\n\\\n/*csslint\\n\\\n*/\\n\\\ntextarea {\\n\\\n    font-family: monospace;\\n\\\n    height: 10rem;\\n\\\n    width: 100%;\\n\\\n}\\n\\\ntextarea[readonly] {\\n\\\n    background: #ddd;\\n\\\n}\\n\\\n</style>\\n\\\n</head>\\n\\\n<body>\\n\\\n<!-- utility2-comment\\n\\\n<div id=\"ajaxProgressDiv1\" style=\"background: #d00; height: 2px; left: 0; margin: 0; padding: 0; position: fixed; top: 0; transition: background 0.5s, width 1.5s; width: 25%;\"></div>\\n\\\nutility2-comment -->\\n\\\n<h1>\\n\\\n<!-- utility2-comment\\n\\\n    <a\\n\\\n        {{#if env.npm_package_homepage}}\\n\\\n        href=\"{{env.npm_package_homepage}}\"\\n\\\n        {{/if env.npm_package_homepage}}\\n\\\n        target=\"_blank\"\\n\\\n    >\\n\\\nutility2-comment -->\\n\\\n        {{env.npm_package_name}} (v{{env.npm_package_version}})\\n\\\n<!-- utility2-comment\\n\\\n    </a>\\n\\\nutility2-comment -->\\n\\\n</h1>\\n\\\n<h3>{{env.npm_package_description}}</h3>\\n\\\n<!-- utility2-comment\\n\\\n<h4><a download href=\"assets.app.js\">download standalone app</a></h4>\\n\\\n<button class=\"onclick onreset\" id=\"testRunButton1\">run internal test</button><br>\\n\\\n<div id=\"testReportDiv1\" style=\"display: none;\"></div>\\n\\\nutility2-comment -->\\n\\\n\\n\\\n\\n\\\n\\n\\\n<label>stderr and stdout</label>\\n\\\n<textarea class=\"resettable\" id=\"outputTextareaStdout1\" readonly></textarea>\\n\\\n<!-- utility2-comment\\n\\\n{{#if isRollup}}\\n\\\n<script src=\"assets.app.js\"></script>\\n\\\n{{#unless isRollup}}\\n\\\nutility2-comment -->\\n\\\n<script src=\"assets.utility2.rollup.js\"></script>\\n\\\n<script src=\"jsonp.utility2._stateInit?callback=window.utility2._stateInit\"></script>\\n\\\n<script src=\"assets.npmtest_dat.rollup.js\"></script>\\n\\\n<script src=\"assets.example.js\"></script>\\n\\\n<script src=\"assets.test.js\"></script>\\n\\\n<!-- utility2-comment\\n\\\n{{/if isRollup}}\\n\\\nutility2-comment -->\\n\\\n<div class=\"utility2FooterDiv\">\\n\\\n    [ this app was created with\\n\\\n    <a href=\"https://github.com/kaizhu256/node-utility2\" target=\"_blank\">utility2</a>\\n\\\n    ]\\n\\\n</div>\\n\\\n</body>\\n\\\n</html>\\n\\\n';\n        /* jslint-ignore-end */\n        if (local.templateRender) {\n            local.assetsDict['/'] = local.templateRender(\n                local.assetsDict['/assets.index.template.html'],\n                {\n                    env: local.objectSetDefault(local.env, {\n                        npm_package_description: 'the greatest app in the world!',\n                        npm_package_name: 'my-app',\n                        npm_package_nameAlias: 'my_app',\n                        npm_package_version: '0.0.1'\n                    })\n                }\n            );\n        } else {\n            local.assetsDict['/'] = local.assetsDict['/assets.index.template.html']\n                .replace((/\\{\\{env\\.(\\w+?)\\}\\}/g), function (match0, match1) {\n                    // jslint-hack\n                    String(match0);\n                    switch (match1) {\n                    case 'npm_package_description':\n                        return 'the greatest app in the world!';\n                    case 'npm_package_name':\n                        return 'my-app';\n                    case 'npm_package_nameAlias':\n                        return 'my_app';\n                    case 'npm_package_version':\n                        return '0.0.1';\n                    }\n                });\n        }\n        // run the cli\n        if (local.global.utility2_rollup || module !== require.main) {\n            break;\n        }\n        local.assetsDict['/assets.example.js'] =\n            local.assetsDict['/assets.example.js'] ||\n            local.fs.readFileSync(__filename, 'utf8');\n        // bug-workaround - long $npm_package_buildCustomOrg\n        /* jslint-ignore-begin */\n        local.assetsDict['/assets.npmtest_dat.rollup.js'] =\n            local.assetsDict['/assets.npmtest_dat.rollup.js'] ||\n            local.fs.readFileSync(\n                local.npmtest_dat.__dirname + '/lib.npmtest_dat.js',\n                'utf8'\n            ).replace((/^#!/), '//');\n        /* jslint-ignore-end */\n        local.assetsDict['/favicon.ico'] = local.assetsDict['/favicon.ico'] || '';\n        // if $npm_config_timeout_exit exists,\n        // then exit this process after $npm_config_timeout_exit ms\n        if (Number(process.env.npm_config_timeout_exit)) {\n            setTimeout(process.exit, Number(process.env.npm_config_timeout_exit));\n        }\n        // start server\n        if (local.global.utility2_serverHttp1) {\n            break;\n        }\n        process.env.PORT = process.env.PORT || '8081';\n        console.error('server starting on port ' + process.env.PORT);\n        local.http.createServer(function (request, response) {\n            request.urlParsed = local.url.parse(request.url);\n            if (local.assetsDict[request.urlParsed.pathname] !== undefined) {\n                response.end(local.assetsDict[request.urlParsed.pathname]);\n                return;\n            }\n            response.statusCode = 404;\n            response.end();\n        }).listen(process.env.PORT);\n        break;\n    }\n}());\n","/home/travis/build/npmtest/node-npmtest-dat/node_modules/dat/lib/dat-json.js":"var fs = require('fs')\nvar stringKey = require('dat-encoding').toStr\nvar path = require('path')\n\nmodule.exports = {\n  read: function (dat, cb) {\n    // dat.json\n    // reads to dat.meta if exists\n    // (TODO: move to module & validate dat.json)\n    fs.readFile(datJsonFile(dat), 'utf8', function (err, body) {\n      if (err) return cb(err)\n      if (!body) return cb(null, {})\n      var meta\n      try {\n        meta = JSON.parse(body)\n      } catch (e) {\n        return cb(new Error('Error reading the dat.json file.'))\n      }\n      cb(null, meta)\n    })\n  },\n  write: function (dat, defaults, cb) {\n    if (typeof defaults === 'function') {\n      cb = defaults\n      defaults = {}\n    }\n    dat.meta = {\n      title: defaults.title || path.basename(dat.path),\n      url: defaults.url,\n      name: defaults.name,\n      description: defaults.description || ''\n    }\n    if (dat.key) dat.meta.url = 'dat://' + stringKey(dat.key)\n    fs.writeFile(datJsonFile(dat), JSON.stringify(dat.meta), cb)\n  }\n}\n\nfunction datJsonFile (dat) {\n  return path.join(dat.path, 'dat.json')\n}\n","/home/travis/build/npmtest/node-npmtest-dat/node_modules/dat-encoding/index.js":"'use strict'\n\nvar Buffer = require('safe-buffer').Buffer\n\nfunction encode (buf) {\n  if (typeof buf === 'string') return encode(decode(buf))\n  if (!Buffer.isBuffer(buf)) throw new Error('Not a buffer')\n  if (buf.length !== 32) throw new Error('Invalid buffer')\n  return buf.toString('hex')\n}\n\nfunction decode (str) {\n  if (Buffer.isBuffer(str)) return decode(encode(str))\n  if (typeof str !== 'string') throw new Error('Not a string')\n  var match = /\\/?([^/]{64})/.exec(str)\n  if (!match) throw new Error('Invalid key')\n  return Buffer.from(match[1], 'hex')\n}\n\nexports.encode = exports.toStr = encode\nexports.decode = exports.toBuf = decode\n","/home/travis/build/npmtest/node-npmtest-dat/node_modules/dat/lib/download.js":"var assert = require('assert')\nvar logger = require('status-logger')\nvar prettyBytes = require('pretty-bytes')\nvar rimraf = require('rimraf')\nvar memdb = require('memdb')\nvar Dat = require('dat-node')\nvar ui = require('./ui')\nvar debug = require('debug')('dat')\n\nmodule.exports = function (type, opts, dat) {\n  assert.ok(type, 'lib/download download type required')\n  assert.ok(['sync', 'clone', 'pull'].indexOf(type) > -1, 'lib/download download type must be sync, clone, pull')\n\n  // TODO: clean up this logic\n  var resume = opts.resume || false\n  var hasKey = (dat && dat.key) || opts.key\n  if (!hasKey && !resume) return ui.exit()('lib/download Key required to download')\n\n  var network = null\n  var stats = null\n  var archive = null\n  var onceConnected = false\n\n  // Logging Init\n  var output = [\n    [\n      'Starting Dat...', // Shows Folder Name\n      '', // Shows Link\n      '', // Shows Metadata Progress Bar\n      '', // Shows Content Progress Bar\n      '', // Shows Total Size Info\n      '' //  spacer before network info\n    ],\n    [] // Shows network information\n  ]\n  var progressOutput = output[0] // shortcut for progress output\n  var log = logger(output, {debug: opts.verbose, quiet: opts.quiet || opts.debug}) // If debug=true we want output to be quiet\n\n  // UI Elements\n  var bar = ui.bar()\n  var exit = ui.exit(log)\n\n  // Printing Things!!\n  if (opts.debug) opts.logspeed = 1000\n  setInterval(function () {\n    if (stats) updateDownload()\n    if (network) updateNetwork()\n    log.print()\n  }, opts.logspeed)\n\n  // Action starts here\n  if (opts.temp) opts.db = memdb()\n  if (!dat) Dat(opts.dir, opts, start)\n  else start(null, dat)\n\n  function start (err, theDat) {\n    if (err) return exit(err)\n\n    dat = theDat\n\n    debug('Download: ' + type + ' on ' + dat.key.toString('hex'))\n\n    archive = dat.archive\n\n    archive.open(function () {\n      if (!archive.content) return removeExit() // Not an archive\n      archive.content.once('download-finished', checkDone)\n    })\n    // TODO: could be optimized for frequent metadata updates\n    archive.metadata.on('update', updateDownload)\n\n    // General Archive Info\n    var niceType = (type === 'clone') ? 'Cloning' : type.charAt(0).toUpperCase() + type.slice(1) + 'ing'\n    progressOutput[0] = `${niceType} Dat Archive: ${dat.path}`\n    progressOutput[1] = ui.link(dat.key) + '\\n'\n    if (opts.quiet && type !== 'clone') process.stdout.write(ui.link(dat.key))\n\n    // Stats\n    stats = dat.trackStats()\n    stats.on('update:blocksProgress', checkDone)\n\n    // Network\n    if (!opts.upload && type !== 'sync') opts.upload = false // Do not upload on pull/clone\n    network = dat.joinNetwork(opts)\n    network.swarm.once('connection', function (peer) {\n      debug('Network: first peer connected')\n      onceConnected = true\n      progressOutput[2] = 'Starting Download...'\n    })\n    progressOutput[2] = 'Looking for Dat Archive in Network'\n\n    function removeExit () {\n      output[0] = ['']\n      output[1] = ['']\n      log.print()\n      if (opts.newDir) rimraf.sync(dat.path)\n      return exit('Link is not a Dat Archive. Please check you have the correct link.')\n    }\n  }\n\n  function updateDownload () {\n    if (!archive.content) {\n      progressOutput[2] = '... Fetching Metadata'\n      return\n    }\n    // TODO: think about how this could work for empty archives & slow metadata downloads\n    if (checkDone()) return\n    var st = stats.get()\n\n    var metaBlocksProgress = archive.metadata.blocks - archive.metadata.blocksRemaining()\n    var metaProgress = Math.round(metaBlocksProgress * 100 / archive.metadata.blocks)\n    var contentBlocksProgress = archive.content.blocks - archive.content.blocksRemaining() // TODO: for archives with history st.blocksProgress may be off?\n    var contentProgress = st.blocksTotal === 0 ? 0 : (contentBlocksProgress * 100 / st.blocksTotal).toFixed(2)\n    if (contentProgress >= 100) contentProgress = 100 // In case + remove decimal from 100.00\n    // TODO: fix hyperdrive-stats bug where blocksProgress > blocksTotal\n    // var contentProgress = st.blocksTotal === 0 ? 0 : Math.round(st.blocksProgress * 100 / st.blocksTotal)\n    progressOutput[2] = 'Metadata: ' + bar(metaProgress) + ' ' + metaProgress + '%'\n    progressOutput[3] = 'Content:  ' + bar(contentProgress) + ' ' + contentProgress + '%'\n\n    if (!onceConnected && dat.live) progressOutput[4] = 'Waiting for connections to check for updates.'\n    else progressOutput[4] = `Total size: ${st.filesTotal} ${st.filesTotal === 1 ? 'file' : 'files'} (${prettyBytes(st.bytesTotal)})`\n\n    if (metaProgress < 100) debug('Metadata Download Progress:', metaProgress + '%')\n    if (contentProgress < 100) debug('Download Progress:', contentProgress + '%', contentBlocksProgress, 'blocks of', st.blocksTotal)\n  }\n\n  function updateNetwork () {\n    output[1] = ui.network(network.connected, stats.network)\n  }\n\n  function checkDone () {\n    if (!onceConnected || archive.metadata.blocksRemaining() !== 0) return false\n    if (!archive.content || archive.content.blocksRemaining() !== 0) return false\n    if (archive.metadata.blocks > 1 && !archive.content.blocks) return false // If metadata.blocks = 1, content feed is empty so finish\n\n    var st = stats.get()\n\n    progressOutput[2] = ''\n    progressOutput[3] = (type === 'sync') ? 'Files updated to latest!' : 'Download Finished!'\n    progressOutput[4] = `Total size: ${st.filesTotal} ${st.filesTotal === 1 ? 'file' : 'files'} (${prettyBytes(st.bytesTotal)})`\n\n    debug('Download finished')\n    if (!opts.exit) return true\n\n    // Exit!\n    output[1] = '' // remove network info\n    return exit()\n  }\n}\n","/home/travis/build/npmtest/node-npmtest-dat/node_modules/dat-node/index.js":"var assert = require('assert')\nvar xtend = require('xtend')\nvar path = require('path')\nvar untildify = require('untildify')\nvar debug = require('debug')('dat-node')\nvar initArchive = require('./lib/init-archive')\nvar Dat = require('./dat')\n\nmodule.exports = createDat\n\nfunction createDat (dirOrDrive, opts, cb) {\n  if (!cb) {\n    cb = opts\n    opts = {}\n  }\n\n  assert.ok(typeof dirOrDrive === 'string' || typeof dirOrDrive === 'object', 'dat-node: dirOrDrive should be type string or type object')\n  assert.equal(typeof opts, 'object', 'dat-node: opts should be type object')\n  assert.equal(typeof cb, 'function', 'dat-node: cb should be type function')\n\n  opts = xtend(opts)\n\n  if (typeof dirOrDrive === 'string') {\n    opts.dir = dirOrDrive\n  } else {\n    opts.drive = dirOrDrive\n  }\n\n  if (!opts.dir) {\n    return cb(new Error('opts.dir must be specified'))\n  }\n\n  opts.dir = path.resolve(untildify(opts.dir))\n\n  debug('Running initArchive on', opts.dir, 'with opts:', opts)\n  initArchive(opts, function (err, archive, db) {\n    if (err) return cb(err)\n    debug('initArchive callback')\n    var dat = new Dat(archive, db, opts)\n    cb(null, dat)\n  })\n}\n","/home/travis/build/npmtest/node-npmtest-dat/node_modules/dat-node/lib/init-archive.js":"var assert = require('assert')\nvar fs = require('fs')\nvar path = require('path')\nvar xtend = require('xtend')\nvar level = require('level')\nvar hyperdrive = require('hyperdrive')\nvar raf = require('random-access-file')\nvar encoding = require('dat-encoding')\nvar debug = require('debug')('dat-node')\n\nmodule.exports = function (opts, cb) {\n  assert.ok(opts, 'dat-node: lib/init-archive opts required')\n  assert.ok(opts.dir, 'dat-node: lib/init-archive dir option required')\n  assert.ok(typeof cb === 'function', 'dat-node: lib/init-archive callback function required')\n\n  var archive\n  var drive\n  var db\n  var dir = opts.dir\n  var key = opts.key ? encoding.toStr(opts.key) : null\n  var dbPath = opts.dbPath || path.join(dir, '.dat')\n  var createIfMissing = !(opts.createIfMissing === false)\n  var errorIfExists = opts.errorIfExists || false\n  var archiveOpts = xtend({\n    file: function (name, opts) {\n      return raf(path.join(dir, name), opts.length, opts && typeof opts.length === 'number' && {length: opts.length})\n    }\n  }, opts)\n\n  // opts.resume backwards compat. TODO: Remove in v2\n  if (opts.resume) createIfMissing = false\n  if (opts.resume === false) errorIfExists = true\n\n  if (opts.db || opts.drive) {\n    drive = opts.drive || hyperdrive(opts.db)\n    db = opts.db ? opts.db : drive.core._db\n    return checkDriveKeys()\n  }\n\n  if (createIfMissing !== false) return createDb()\n\n  try {\n    // check if existing dbPath\n    if (!fs.statSync(dbPath).isDirectory()) throw new Error('.dat folder not a dir')\n    return createDb()\n  } catch (e) {\n    return cb(new Error('No existing .dat folder'))\n  }\n\n  function createDb () {\n    debug('Making/Reading archive database')\n    level(dbPath, {\n      createIfMissing: createIfMissing,\n      errorIfExists: errorIfExists\n    }, function (err, _db) {\n      if (err) return cb(err)\n      db = _db\n      drive = hyperdrive(db)\n      checkDriveKeys()\n    })\n  }\n\n  function checkDriveKeys () {\n    // Try to resume archives if there are keys in the drive\n    debug('Reading existing keys in drive')\n    drive.core.list(function (err, keys) {\n      if (err) return cb(err)\n\n      if (keys.length > 2 && !key) return cb(new Error('Drive has multiple archives. Must specify key.'))\n      else if (errorIfExists && keys.length) {\n        return db.close(function () {\n          cb(new Error('Existing feeds in database.'))\n        })\n      }\n\n      keys = keys.map(function (val) {\n        return encoding.toStr(val)\n      })\n      debug(`Drive has ${keys.length} existing keys.`)\n      if (keys.length) {\n        debug('keys:', keys)\n      }\n\n      // Error if opts.key is used and doesn't match anything in database\n      if (keys.length && key && keys.indexOf(key) === -1) {\n        return db.close(function () {\n          cb(new Error('Existing archive in database does not match key option.'))\n        })\n      }\n\n      if (key) {\n        debug('Using key option for archive', key)\n        archive = drive.createArchive(key, archiveOpts)\n        archive.resumed = (keys.length === 2) // resumed = true if existing archive\n        return doneArchive(keys.length < 2 && key) // do not open if new drive and external key (e.g. downloading)\n      } else if (!keys.length) {\n        // create a new database + archive\n        debug('No existing feeds in drive, creating new archive.')\n        archive = drive.createArchive(null, archiveOpts)\n        archive.resumed = false\n        return doneArchive(false) // open archive - no external key so we are making new archive locally\n      }\n      // opts.key = null && keys.length === 2\n      tryOpen()\n\n      function tryOpen () {\n        // Just in case: double check our logic here =)\n        assert.ok(!key, 'dat-node: lib/init-archive tryOpen should be called if we opts.key is used')\n        assert.ok(keys.length && keys.length <= 2, `dat-node: lib/init-archive tryOpen 1-2 values in database, db has ${keys.length}`)\n\n        // Existing Keys, No key Option\n        // Guess which key is metadata\n        // If first key fails, use other key\n        debug('Making archive with key', keys[keys.length - 1].toString('hex'))\n        archive = drive.createArchive(keys[keys.length - 1], archiveOpts)\n        var openTimeout = setTimeout(function () {\n          debug('Timeout Open')\n          tryOtherKey()\n        }, 150)\n        archive.open(function (err) {\n          clearTimeout(openTimeout)\n          if (!err) return doneArchive()\n          var badKey = err && (err.message.indexOf('Unknown message type') > -1 || err.message.indexOf('Key not found in database') > -1)\n          if (err & !badKey) return cb(err)\n          tryOtherKey()\n        })\n      }\n\n      function tryOtherKey () {\n        archive.close(function (err) {\n          if (err) debug(err) // Hopefully no error but we just want this thing closed!\n          debug('Bad Key. Trying other key.')\n          archive = drive.createArchive(keys[0], archiveOpts)\n          doneArchive()\n        })\n      }\n    })\n  }\n\n  function doneArchive (doNotOpen) {\n    debug('Archive initialized')\n    if (archive.key) debug('Archive key', archive.key.toString('hex'))\n    // doNotOpen = true if no existing feeds in drive\n    // Opening would have to wait for swarm connection\n    if (doNotOpen) return cb(null, archive, db)\n\n    if (archive.resumed !== false) archive.resumed = true\n\n    if (archive.key) debug('Opening archive', archive.key.toString('hex'))\n    else debug('Opening snapshot archive')\n    archive.open(function (err) {\n      if (err) return cb(err)\n      debug('Archive opened')\n      if (archive.owner && !opts.file) {\n        // Do not use opts.length for archive owners\n        // May cause source corruption\n        archive.options.file = function (name, opts) {\n          return raf(path.join(dir, name))\n        }\n      }\n      cb(null, archive, db)\n    })\n  }\n}\n","/home/travis/build/npmtest/node-npmtest-dat/node_modules/dat-node/dat.js":"var assert = require('assert')\nvar path = require('path')\nvar multicb = require('multicb')\nvar xtend = require('xtend')\nvar importFiles = require('./lib/import-files')\nvar createNetwork = require('./lib/network')\nvar stats = require('./lib/stats')\nvar debug = require('debug')('dat-node')\n\nmodule.exports = Dat\n\nfunction Dat (archive, db, opts) {\n  if (!(this instanceof Dat)) return new Dat(archive, db, opts)\n  if (typeof opts === 'undefined') return Dat(archive, null, db)\n  assert.ok(archive, 'archive required')\n  // assert.ok(db, 'database required') // maybe not be required for multidrive...\n  assert.ok(opts.dir, 'opts.directory required')\n\n  this.path = path.resolve(opts.dir)\n  this.options = xtend(opts)\n\n  this.archive = archive\n  this.db = db\n\n  var self = this\n\n  // Getters for convenience accessors\n  Object.defineProperties(this, {\n    key: {\n      enumerable: true,\n      get: function () {\n        return self.archive.key\n      }\n    },\n    live: {\n      enumerable: true,\n      get: function () {\n        return self.archive.live\n      }\n    },\n    owner: {\n      enumerable: true,\n      get: function () {\n        return self.archive.owner\n      }\n    },\n    resumed: {\n      enumerable: true,\n      get: function () {\n        return self.archive.resumed\n      }\n    }\n  })\n}\n\nDat.prototype.join =\nDat.prototype.joinNetwork = function (opts, cb) {\n  if (typeof opts === 'function') {\n    cb = opts\n    opts = {}\n  }\n\n  var self = this\n  if (!opts && self.options.network) opts = self.options.network // use previous options\n  else opts = opts || {}\n  cb = cb || noop\n\n  var netOpts = xtend({\n    stream: function (peer) {\n      var stream = self.archive.replicate({\n        upload: !(opts.upload === false),\n        download: !self.archive.owner && opts.download\n      })\n      stream.on('error', function (err) {\n        debug('Replication error:', err.message)\n      })\n      return stream\n    }\n  }, opts)\n\n  var network = self.network = createNetwork(self.archive, netOpts, cb)\n  self.options.network = netOpts\n  network.swarm = network // 1.0 backwards compat. TODO: Remove in v2\n\n  if (self.owner) return network\n\n  network.once('connection', function () {\n    // automatically open archive\n    self.archive.open(noop)\n  })\n  return network\n}\n\nDat.prototype.leave =\nDat.prototype.leaveNetwork = function (cb) {\n  if (!this.network) return\n  debug('leaveNetwork()')\n  this.archive.unreplicate()\n  this.network.leave(this.archive.discoveryKey)\n  this.network.destroy(cb)\n  delete this.network\n}\n\nDat.prototype.pause = function () {\n  debug('pause()')\n  this.leave()\n}\n\nDat.prototype.resume = function () {\n  debug('resume()')\n  this.join()\n}\n\nDat.prototype.trackStats = function (opts) {\n  opts = opts || {}\n  assert.ok(opts.db || this.db, 'Dat needs database to track stats')\n  this.stats = stats(this.archive, opts.db || this.db)\n  return this.stats\n}\n\nDat.prototype.importFiles = function (target, opts, cb) {\n  if (!this.archive.owner) throw new Error('Must be archive owner to import files.')\n  if (typeof target !== 'string') return this.importFiles('', target, opts)\n  if (typeof opts === 'function') return this.importFiles(target, {}, opts)\n\n  var self = this\n  target = target && target.length ? target : self.path\n  opts = xtend({\n    indexing: opts && opts.indexing || (target === self.path)\n  }, opts)\n\n  self.importer = importFiles(self.archive, target, opts, cb)\n  self.options.importer = self.importer.options\n  return self.importer\n}\n\nDat.prototype.close = function (cb) {\n  cb = cb || noop\n  if (this._closed) return cb(new Error('Dat is already closed'))\n\n  var self = this\n  self._closed = true\n  self.archive.unreplicate()\n\n  var done = multicb()\n  closeNet(done())\n  closeFileWatch(done())\n  closeArchiveDb(done())\n\n  done(cb)\n\n  function closeArchiveDb (cb) {\n    self.archive.close(function (err) {\n      if (err) return cb(err)\n      if (self.options.db || !self.db) return cb(null)\n      closeDb(cb)\n    })\n  }\n\n  function closeDb (cb) {\n    if (!self.db) return cb()\n    self.db.close(cb)\n  }\n\n  function closeNet (cb) {\n    if (!self.network) return cb()\n    self.leave(cb)\n  }\n\n  function closeFileWatch (cb) {\n    if (!self.importer) return cb()\n    self.importer.close()\n    process.nextTick(function () {\n      // TODO: dat importer close is currently sync-ish\n      cb()\n    })\n  }\n}\n\nfunction noop () { }\n","/home/travis/build/npmtest/node-npmtest-dat/node_modules/dat-node/lib/import-files.js":"var assert = require('assert')\nvar fs = require('fs')\nvar path = require('path')\nvar match = require('anymatch')\nvar countFiles = require('count-files')\nvar hyperImport = require('hyperdrive-import-files')\nvar debug = require('debug')('dat-node')\n\nmodule.exports = importer\n\nfunction importer (archive, target, opts, cb) {\n  assert.ok(archive, 'lib/import-files archive required')\n  assert.ok(target, 'lib/import-files target directory required')\n  if (typeof opts === 'function') return importer(archive, target, {}, opts)\n\n  opts = opts || {}\n  opts.ignore = opts.ignore // we want an array here\n    ? Array.isArray(opts.ignore)\n      ? opts.ignore\n      : [opts.ignore]\n    : []\n  var defaultIgnore = [/^(?:\\/.*)?\\.dat(?:\\/.*)?$/] // ignore .dat\n  var ignoreHidden = [/[/\\\\]\\./]\n  var datIgnore = !(opts.useDatIgnore === false) ? getDatIgnore(target) : []\n\n  // Add ignore options\n  opts.ignore = opts.ignore.concat(defaultIgnore) // always ignore .dat folder\n  if (datIgnore) opts.ignore = opts.ignore.concat(datIgnore) // add .datignore\n  if (opts.ignoreHidden !== false) opts.ignore = opts.ignore.concat(ignoreHidden) // ignore all hidden things\n\n  var importer = hyperImport(archive, target, opts, cb)\n  importer.options = importer.options || opts\n\n  debug('Importer created. Counting Files.')\n  // Start counting the files\n  var countStats = countFiles(target, {\n    ignore: function (file) {\n      return match(opts.ignore, file)\n    }\n  }, function (err, stats) {\n    if (err) cb(err)\n    debug('File count finished', countStats)\n    importer.emit('count finished', countStats)\n  })\n  importer.countStats = countStats // TODO: make importer vs count stats clearer\n\n  return importer\n}\n\nfunction getDatIgnore (dir) {\n  try {\n    return fs.readFileSync(path.join(dir, '.datignore'), 'utf8')\n      .split('\\n')\n      .filter(function (str) {\n        return !!str.trim()\n      })\n      .map(function (line) {\n        return path.join(dir, line) // prepend the dir to each line\n      })\n  } catch (e) {\n    return []\n  }\n}\n","/home/travis/build/npmtest/node-npmtest-dat/node_modules/dat-node/lib/network.js":"var assert = require('assert')\nvar swarmDefaults = require('datland-swarm-defaults')\nvar disc = require('discovery-swarm')\nvar xtend = require('xtend')\n\nmodule.exports = function (archive, opts, cb) {\n  assert.ok(archive, 'dat-node: lib/network archive required')\n  assert.ok(opts, 'dat-node: lib/network opts required')\n\n  var DEFAULT_PORT = 3282\n  var swarmOpts = xtend({\n    id: archive.id,\n    hash: false,\n    stream: opts.stream\n  }, opts)\n  var swarm = disc(swarmDefaults(swarmOpts))\n  swarm.once('error', function () {\n    swarm.listen(0)\n  })\n  swarm.listen(opts.port || DEFAULT_PORT)\n  swarm.join(archive.discoveryKey, { announce: !(opts.upload === false) }, cb)\n  swarm.options = swarm._options\n  return swarm\n}\n","/home/travis/build/npmtest/node-npmtest-dat/node_modules/datland-swarm-defaults/index.js":"var extend = require('xtend')\n\nvar DAT_DOMAIN = 'dat.local'\nvar DEFAULT_DISCOVERY = [\n  'discovery1.publicbits.org',\n  'discovery2.publicbits.org'\n]\nvar DEFAULT_BOOTSTRAP = [\n  'bootstrap1.publicbits.org:6881',\n  'bootstrap2.publicbits.org:6881',\n  'bootstrap3.publicbits.org:6881',\n  'bootstrap4.publicbits.org:6881'\n]\n\nvar DEFAULT_OPTS = {\n  dns: {server: DEFAULT_DISCOVERY, domain: DAT_DOMAIN},\n  dht: {bootstrap: DEFAULT_BOOTSTRAP}\n}\n\nmodule.exports = function (opts) {\n  return extend(DEFAULT_OPTS, opts) // opts takes priority\n}\n","/home/travis/build/npmtest/node-npmtest-dat/node_modules/dat-node/lib/stats.js":"var assert = require('assert')\nvar Stats = require('hyperdrive-stats')\nvar sub = require('subleveldown')\nvar encoding = require('dat-encoding')\nvar networkSpeed = require('hyperdrive-network-speed')\n\nmodule.exports = function (archive, db) {\n  assert.ok(archive, 'lib/stats archive required')\n  assert.ok(db, 'lib/stats db required')\n\n  var stats = Stats({\n    archive: archive,\n    db: sub(db, `${encoding.toStr(archive.discoveryKey)}-stats`)\n  })\n  stats.network = networkSpeed(archive, {timeout: 2000})\n\n  Object.defineProperties(stats, {\n    peers: {\n      enumerable: true,\n      get: function () {\n        if (!archive.content || !archive.content.peers) return {} // TODO: how to handle this?\n        var peers = archive.content.peers\n        var total = peers.length\n        var downloadingFrom = peers.filter(function (peer) {\n          return peer.downloaded\n        }).length\n        var complete = peers.filter(function (peer) {\n          return peer.remoteLength === archive.content.blocks\n        }).length\n\n        return {\n          total: total,\n          downloadingFrom: downloadingFrom,\n          complete: complete\n        }\n      }\n    }\n  })\n\n  return stats\n}\n","/home/travis/build/npmtest/node-npmtest-dat/node_modules/dat/lib/ui/index.js":"module.exports.bar = require('./bar')\nmodule.exports.exit = require('./exit')\nmodule.exports.exitErr = function (err) {\n  // shortcut\n  require('./exit')()(err)\n}\nmodule.exports.importProgress = require('./import-progress')\nmodule.exports.link = require('./link')\nmodule.exports.network = require('./network')\n","/home/travis/build/npmtest/node-npmtest-dat/node_modules/dat/lib/ui/bar.js":"var progress = require('progress-string')\n\nmodule.exports = function () {\n  return progress({\n    width: 50,\n    total: 100,\n    style: function (complete, incomplete) {\n      return '[' + complete + '>' + incomplete + ']'\n    }\n  })\n}\n","/home/travis/build/npmtest/node-npmtest-dat/node_modules/dat/lib/ui/exit.js":"var readline = require('readline')\nvar debug = require('debug')('dat')\n\nmodule.exports = function (log) {\n  return function (err) {\n    if (err) {\n      readline.cursorTo(process.stdout, 0)\n      readline.clearLine(process.stdout)\n      if (debug.enabled) console.trace(err)\n      else console.error(err)\n      process.exit(1)\n    }\n    if (log) log.print()\n    process.exit(0)\n  }\n}\n","/home/travis/build/npmtest/node-npmtest-dat/node_modules/dat/lib/ui/import-progress.js":"var Bar = require('./bar')\nvar prettyBytes = require('pretty-bytes')\n\nmodule.exports = function () {\n  var bar = Bar()\n  var start = Date.now()\n  return function (importer) {\n    if (!importer || !importer.bytesImported) return ''\n    var importedBytes = importer.bytesImported\n    var importedFiles = importer.fileCount - 1 // counted before import finishes so -1 TODO: fix?\n    var speed = importer.bytesImported * 1000 / (Date.now() - start)\n    var progress = Math.round(importedBytes * 100 / importer.countStats.bytes)\n    return bar(progress) + ` ${importedFiles} of ${importer.countStats.files} ${importer.countStats.files === 1 ? 'file' : 'files'}` + ' (' + prettyBytes(speed) + '/s' + ')'\n  }\n}\n","/home/travis/build/npmtest/node-npmtest-dat/node_modules/dat/lib/ui/link.js":"var stringKey = require('dat-encoding').toStr\n\nmodule.exports = function (key) {\n  return `Link: dat://${stringKey(key)}`\n}\n","/home/travis/build/npmtest/node-npmtest-dat/node_modules/dat/lib/ui/network.js":"var prettyBytes = require('pretty-bytes')\n\nmodule.exports = function (peers, stats) {\n  if (!peers) return ['Looking for connections in Dat Network...']\n  var msg = []\n  msg.push(`${peers} ${peers === 1 ? 'peer' : 'peers'} on the Dat Network`)\n  var spdMsg = ''\n  if (stats.downloadSpeed) spdMsg += `Downloading: ${prettyBytes(stats.downloadSpeed)}/s` + '  '\n  if (stats.uploadSpeed) spdMsg += `Uploading: ${prettyBytes(stats.uploadSpeed)}/s`\n  msg.push(spdMsg)\n  return msg\n}\n","/home/travis/build/npmtest/node-npmtest-dat/node_modules/dat/lib/registry.js":"var xtend = require('xtend')\nvar RegistryClient = require('dat-registry')\n\nmodule.exports = function (opts) {\n  var townshipOpts = {\n    server: opts.server,\n    config: {\n      filepath: opts.config || '.datrc'\n    }\n  }\n  var defaults = {\n    // xtend doesn't overwrite when key is present but undefined\n    // If we want a default, make sure it's not going to passed as undefined\n  }\n  var options = xtend(defaults, townshipOpts)\n  return RegistryClient(options)\n}\n","/home/travis/build/npmtest/node-npmtest-dat/node_modules/dat-registry/index.js":"var Township = require('township-client')\nvar qs = require('querystring')\nvar nets = require('nets')\nvar xtend = require('xtend')\n\nmodule.exports = API\n\nfunction API (opts) {\n  if (!(this instanceof API)) return new API(opts)\n  if (!opts) opts = {}\n  var server = opts.server || 'https://datproject.org'\n  var api = server + '/api/v1'\n  var township = Township(xtend(opts, {\n    server: api // used over opts.server\n  }))\n  return {\n    login: township.login.bind(township),\n    logout: township.logout.bind(township),\n    register: township.register.bind(township),\n    whoami: township.getLogin.bind(township),\n    secureRequest: township.secureRequest.bind(township),\n    dats: rest('/dats'),\n    users: xtend(rest('/users'), {\n      resetPassword: function(input, cb) {\n        nets({method: 'POST', uri: api + '/password-reset', body: input, json: true}, cb)\n      },\n      resetPasswordConfirmation: function(input, cb) {\n        nets({method: 'POST', uri: api + '/password-reset-confirm', body: input, json: true}, cb)\n      }\n    })\n  }\n\n  function rest (path) {\n    var defaults = {\n      uri: api + path,\n      json: true\n    }\n    return {\n      get: function (input, cb) {\n        var params = qs.stringify(input)\n        var opts = Object.assign({}, defaults)\n        opts.uri = defaults.uri + '?' + params\n        opts.method = 'GET'\n        township.secureRequest(opts, cb)\n      },\n      create: function (input, cb) {\n        var opts = Object.assign({}, defaults)\n        opts.body = input\n        opts.method = 'POST'\n        township.secureRequest(opts, cb)\n      },\n      update: function (input, cb) {\n        if (!input.id) throw new Error('id required')\n        var opts = Object.assign({}, defaults)\n        opts.body = input\n        opts.method = 'PUT'\n        township.secureRequest(opts, cb)\n      },\n      delete: function (input, cb) {\n        if (!input.id) throw new Error('id required')\n        var opts = Object.assign({}, defaults)\n        opts.body = input\n        opts.method = 'DELETE'\n        township.secureRequest(opts, cb)\n      }\n    }\n  }\n}\n","/home/travis/build/npmtest/node-npmtest-dat/node_modules/dat/lib/share.js":"var assert = require('assert')\nvar basename = require('path').basename\nvar logger = require('status-logger')\nvar prettyBytes = require('pretty-bytes')\nvar xtend = require('xtend')\nvar Dat = require('dat-node')\nvar ui = require('./ui')\nvar debug = require('debug')('dat')\n\nmodule.exports = function sync (type, opts, dat) {\n  assert.ok(type, 'lib/share share type required')\n  assert.ok(['sync'].indexOf(type) > -1, 'lib/share type must be sync')\n\n  debug('Share: ' + type + ' on ' + dat.key.toString('hex'))\n\n  var importDone = false\n  var importStatus = null\n  var network = null\n  var stats = null\n  var fileOutput, liveProgressOutput\n\n  // Logging Init.\n  // After download require because downloader has it's own logger\n  var output = [\n    [\n      'Starting Dat...', // Shows Folder Name\n      '', // Shows Link\n      '', // Shows Importing Progress Bar\n      '', // Shows Total Size Info\n      '' //  spacer before network info\n    ],\n    [''] // Shows network information\n  ]\n  var progressOutput = output[0] // shortcut for progress output\n  if (opts.watch) {\n    output.push(['', '', ''], []) // progress bar, live file list\n    liveProgressOutput = output[2]\n    fileOutput = output[3]\n  }\n  var log = logger(output, {debug: opts.verbose, quiet: opts.quiet || opts.debug}) // If debug=true we want output to be quiet.\n\n  // UI Elements\n  var importUI = ui.importProgress()\n  var exit = ui.exit(log)\n\n  // Printing Things!!\n  setInterval(function () {\n    if (importStatus && !importDone) updateImport()\n    if (network) updateNetwork()\n    log.print()\n  }, opts.logspeed)\n\n  // Action starts here\n  if (!dat) Dat(opts.dir, opts, start)\n  else start(null, dat)\n\n  function start (err, theDat) {\n    if (err) return exit(err)\n\n    dat = theDat\n\n    // General Archive Info\n    progressOutput[0] = `Syncing Dat Archive: ${dat.path}`\n    progressOutput[1] = ui.link(dat.key) + '\\n'\n    if (opts.quiet) process.stdout.write(ui.link(dat.key))\n\n    // Stats (used for network + download)\n    stats = dat.trackStats()\n\n    // Network\n    var networkOpts = xtend(opts, {})\n    if (dat.owner) networkOpts.download = false\n    network = dat.joinNetwork(networkOpts)\n    network.swarm.once('connection', function () {\n      debug('Network: first peer connected')\n    })\n\n    if (dat.owner && opts.import) {\n      debug('Importing updated & new files into archive')\n      // File Imports\n      progressOutput[2] = 'Importing files...'\n\n      importStatus = dat.importFiles({\n        watch: opts.watch,\n        resume: true,\n        ignoreHidden: opts.ignoreHidden,\n        compareFileContent: true\n      }, function (err) {\n        if (err) return exit(err)\n        debug('Import finished')\n        var st = stats.get()\n        importDone = true\n        progressOutput[2] = opts.watch ? 'Watching for file changes...' : 'Archive update finished! Sharing latest files.'\n        progressOutput[3] = `Total Size: ${st.filesTotal} ${st.filesTotal === 1 ? 'file' : 'files'} (${prettyBytes(st.bytesTotal)})`\n\n        if (opts.watch) {\n          var pending = 0\n          importStatus.on('file watch event', function (file) {\n            pending++\n            debug(`File watch ${file.mode}: ${basename(file.path)}`)\n            // liveProgressOutput.splice(2, 0, `Importing: ${ basename(file.path)}`)\n            // liveProgressOutput.splice(-2, 1)\n          })\n          importStatus.on('file imported', function (file) {\n            if (fileOutput.length > 6) {\n              fileOutput.pop()\n            }\n            var fileAction = file.mode === 'created' ? 'Added' : 'Updated'\n            fileOutput.unshift(`${fileAction}: ${basename(file.path)}`)\n            pending--\n            debug(`File ${file.mode}: ${basename(file.path)}`)\n          })\n          importStatus.on('file skipped', function (file) {\n            pending--\n            debug(`File skipped: ${basename(file.path)}`)\n          })\n          setInterval(function () {\n            var st = stats.get()\n            if (pending) liveProgressOutput[1] = `Importing ${pending} files...`\n            else liveProgressOutput[1] = ''\n            progressOutput[3] = `Total Size: ${st.filesTotal} ${st.filesTotal === 1 ? 'file' : 'files'} (${prettyBytes(st.bytesTotal)})`\n          }, opts.logspeed)\n        }\n      })\n\n      if (debug.enabled && importStatus) {\n        importStatus.on('file imported', function (file) {\n          debug(`Imported ${file.path}`)\n        })\n        setInterval(function () {\n          if (!importDone) debug(`Imported ${prettyBytes(importStatus.bytesImported)} of ${prettyBytes(importStatus.countStats.bytes)}`)\n        }, opts.logspeed)\n      }\n    }\n  }\n\n  function updateImport () {\n    progressOutput[3] = importUI(importStatus)\n  }\n\n  function updateNetwork () {\n    output[1] = ui.network(network.connected, stats.network)\n  }\n}\n","/home/travis/build/npmtest/node-npmtest-dat/node_modules/dat/lib/usage.js":"module.exports = function (opts, help, usage) {\n  if (opts.version) {\n    var pkg = require('../package.json')\n    console.error(pkg.version)\n    process.exit(1)\n  }\n  console.error('Usage: dat <cmd> [options]')\n  console.error('')\n  console.error('Sharing Files:')\n  console.error('   dat create [<dir>]          create a local archive')\n  console.error('   dat sync                    watch for changes & sync files with the network')\n  console.error('   dat share                   create and sync an archive in one command!')\n  console.error('   dat snapshot                create a local snapshot archive')\n  console.error('')\n  console.error('Downloading Files:')\n  console.error('   dat clone <link> [<dir>]    clone a remote archive')\n  console.error('   dat pull                    update from remote archive & exit')\n  console.error('   dat sync                    sync files with the network')\n  console.error('')\n  console.error('Help & Troubleshooting:')\n  console.error('   dat doctor                  run the dat network doctor')\n  console.error('   dat [<command>] --help, -h  print help for a command')\n  console.error('   dat --version, -v           print your dat version')\n  console.error('')\n  if (usage) {\n    console.error('General Options:')\n    console.error(usage)\n  }\n  console.error('Have fun using Dat! Learn more at docs.datproject.org')\n  process.exit(1)\n}\n","/home/travis/build/npmtest/node-npmtest-dat/node_modules/dat/scripts/auth-server.js":"var createServer = require('../tests/helpers/auth-server')\n\ncreateServer(process.env.PORT || 8888, function (err, server, closeServer) {\n  if (err) throw err\n\n  process.on('exit', close)\n  process.on('SIGINT', close)\n\n  function close (cb) {\n    closeServer(function () {\n      process.exit()\n    })\n  }\n})\n","/home/travis/build/npmtest/node-npmtest-dat/node_modules/dat/tests/helpers/auth-server.js":"var path = require('path')\nvar Server = require('dat-land/server')\nvar initDb = require('dat-land/server/database/init')\nvar rimraf = require('rimraf')\nvar mockTransport = require('nodemailer-mock-transport')\n\nmodule.exports = createServer\n\nfunction createServer (port, cb) {\n  var config = {\n    email: {\n      fromEmail: 'hi@example.com',\n      transport: mockTransport()\n    },\n    township: {\n      secret: 'very secret code',\n      db: path.join(__dirname, '..', 'test-township.db')\n    },\n    db: {\n      dialect: 'sqlite3',\n      connection: { filename: path.join(__dirname, '..', 'test-sqlite.db') },\n      useNullAsDefault: true\n    },\n    archiver: path.join(__dirname, '..', 'test-archiver'),\n    whitelist: false,\n    port: port || 8888\n  }\n  rimraf.sync(config.archiver)\n  rimraf.sync(config.db.connection.filename)\n  rimraf.sync(config.township.db)\n\n  initDb(config.db, function (err, db) {\n    if (err) return cb(err)\n\n    const server = Server(config, db)\n    server.listen(config.port, function () {\n      console.log('listening', config.port)\n    })\n\n    cb(null, server, close)\n\n    function close (cb) {\n      server.close(function () {\n        rimraf.sync(config.township.db)\n        rimraf.sync(config.db.connection.filename)\n        process.exit()\n      })\n    }\n  })\n}\n"}